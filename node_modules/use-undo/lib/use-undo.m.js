import { useReducer, useCallback } from 'react';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var ActionType;

(function (ActionType) {
  ActionType["Undo"] = "UNDO";
  ActionType["Redo"] = "REDO";
  ActionType["Set"] = "SET";
  ActionType["Reset"] = "RESET";
})(ActionType || (ActionType = {}));

var initialState = {
  past: [],
  present: null,
  future: []
};

var useUndo = function useUndo(initialPresent, opts) {
  if (opts === void 0) {
    opts = {};
  }

  var _useCheckpoints$opts = _extends({
    useCheckpoints: false
  }, opts),
      useCheckpoints = _useCheckpoints$opts.useCheckpoints;

  var reducer = function reducer(state, action) {
    var past = state.past,
        present = state.present,
        future = state.future;

    switch (action.type) {
      case ActionType.Undo:
        {
          if (past.length === 0) {
            return state;
          }

          var previous = past[past.length - 1];
          var newPast = past.slice(0, past.length - 1);
          return {
            past: newPast,
            present: previous,
            future: [present].concat(future)
          };
        }

      case ActionType.Redo:
        {
          if (future.length === 0) {
            return state;
          }

          var next = future[0];
          var newFuture = future.slice(1);
          return {
            past: [].concat(past, [present]),
            present: next,
            future: newFuture
          };
        }

      case ActionType.Set:
        {
          var isNewCheckpoint = useCheckpoints ? !!action.historyCheckpoint : true;
          var newPresent = action.newPresent;

          if (newPresent === present) {
            return state;
          }

          return {
            past: isNewCheckpoint === false ? past : [].concat(past, [present]),
            present: newPresent,
            future: []
          };
        }

      case ActionType.Reset:
        {
          var _newPresent = action.newPresent;
          return {
            past: [],
            present: _newPresent,
            future: []
          };
        }
    }
  };

  var _useReducer = useReducer(reducer, _extends({}, initialState, {
    present: initialPresent
  })),
      state = _useReducer[0],
      dispatch = _useReducer[1];

  var canUndo = state.past.length !== 0;
  var canRedo = state.future.length !== 0;
  var undo = useCallback(function () {
    if (canUndo) {
      dispatch({
        type: ActionType.Undo
      });
    }
  }, [canUndo]);
  var redo = useCallback(function () {
    if (canRedo) {
      dispatch({
        type: ActionType.Redo
      });
    }
  }, [canRedo]);
  var set = useCallback(function (newPresent, checkpoint) {
    if (checkpoint === void 0) {
      checkpoint = false;
    }

    dispatch({
      type: ActionType.Set,
      newPresent: newPresent,
      historyCheckpoint: checkpoint
    });
  }, []);
  var reset = useCallback(function (newPresent) {
    return dispatch({
      type: ActionType.Reset,
      newPresent: newPresent
    });
  }, []);
  return [state, {
    set: set,
    reset: reset,
    undo: undo,
    redo: redo,
    canUndo: canUndo,
    canRedo: canRedo
  }];
};

export default useUndo;
